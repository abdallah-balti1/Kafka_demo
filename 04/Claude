// Dans votre service SignalR ou dans ChatConversationListComponent

// Ajoutez cette mÃ©thode dans ngOnInit pour Ã©couter les nouvelles discussions
ngOnInit(): void {
  // ... votre code existant ...
  
  // Ã‰couter les nouvelles discussions crÃ©Ã©es par d'autres utilisateurs
  this.signalRService.hubConnection.on('NewDiscussionCreated', (newDiscussion: Discussion) => {
    // Ajouter la nouvelle discussion Ã  la liste
    this.activeDiscussions.unshift(newDiscussion);
    this.allDiscussions.unshift(newDiscussion);
    
    // Optionnel: afficher une notification
    console.log('Nouvelle discussion crÃ©Ã©e:', newDiscussion.name);
  });
  
  // Nettoyer les listeners
  this.subscription.add(
    this.signalRService.hubConnection.onclose(() => {
      console.log('Connexion SignalR fermÃ©e');
    })
  );
}

// Modifiez la mÃ©thode createDiscussion pour broadcaster
createDiscussion() {
  this.signalRService.createDiscussion("new discussion").then(discussionId => {
    if (discussionId !== -1) {
      const newDiscussion = new Discussion(
        discussionId, 
        "new discussion", 
        '', 
        new Date(), 
        new Date(), 
        true, 
        '', 
        0, 
        0, 
        0, 
        0, 
        null, 
        false, 
        0
      );
      
      // Ajouter localement





/* Dans chat-conversation-list.component.scss */

.discussion-item {
  padding: 10px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  transition: all 0.3s ease;
}

.discussion-item:hover {
  background-color: #f5f5f5;
}

.discussion-item.selected {
  background-color: #007bff;
  color: white;
}

/* Styles pour les discussions expirÃ©es */
.discussion-item.expired-discussion {
  opacity: 0.6;
  color: #888;
  background-color: #f9f9f9;
  border-left: 3px solid #ffc107;
}

.discussion-item.expired-discussion:hover {
  background-color: #f0f0f0;
}

.discussion-item.expired-discussion.selected {
  background-color: #6c757d !important;
  color: white;
}

.discussion-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.discussion-name {
  flex-grow: 1;
  margin-right: 10px;
}

.expired-badge {
  font-size: 12px;
  margin-left: 5px;
}

.discussion-date {
  font-size: 11px;
  opacity: 0.7;
  margin-left: 10px;
}

/* Animation pour les nouvelles discussions */
.discussion-item.new-discussion {
  animation: slideIn 0.5s ease-out;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
      this.activeDiscussions.unshift(newDiscussion);
      this.allDiscussions.unshift(newDiscussion);
      
      // Broadcaster aux autres clients (cÃ´tÃ© serveur)
      this.signalRService.broadcastNewDiscussion(newDiscussion);
      
      this.changeDiscussion(discussionId, 0);
    }
  });
}





<!-- Dans le template chat-conversation-list.component.html -->

<!-- Modifiez la section de la liste des discussions -->
<div *ngFor="let discussion of activeDiscussions; let i = index" 
     class="discussion-item"
     [ngClass]="getDiscussionClass(discussion)"
     [class.selected]="discussion.selected"
     (click)="changeDiscussion(discussion.id, i)">
     
  <!-- Ajoutez un indicateur pour les discussions expirÃ©es -->
  <div class="discussion-content">
    <span class="discussion-name">{{ discussion.name }}</span>
    
    <!-- Indicateur de discussion expirÃ©e -->
    <span *ngIf="isDiscussionExpired(discussion)" 
          class="expired-badge"
          title="Cette discussion a plus d'une heure">
      ðŸ•’
    </span>
    
    <!-- Affichage de la date de fin si disponible -->
    <small class="discussion-date" *ngIf="discussion.endDate">
      {{ discussion.endDate | date:'dd/MM HH:mm' }}
    </small>
  </div>
</div>

// Dans ChatConversationListComponent, ajoutez ces mÃ©thodes:

/**
 * VÃ©rifie si une discussion a plus d'une heure
 */
isDiscussionExpired(discussion: Discussion): boolean {
  if (!discussion.endDate) return false;
  
  const now = new Date();
  const endTime = new Date(discussion.endDate);
  const diffInMilliseconds = now.getTime() - endTime.getTime();
  const diffInHours = diffInMilliseconds / (1000 * 60 * 60);
  
  return diffInHours > 1;
}

/**
 * Retourne la classe CSS pour une discussion
 */
getDiscussionClass(discussion: Discussion): string {
  let classes = '';
  
  if (this.isDiscussionExpired(discussion)) {
    classes += 'expired-discussion ';
  }
  
  if (discussion.isActive) {
    classes += 'active-discussion ';
  }
  
  return classes.trim();
}

/**
 * VÃ©rifie si une discussion peut Ãªtre sÃ©lectionnÃ©e
 */
canSelectDiscussion(discussion: Discussion): boolean {
  // Les discussions expirÃ©es restent consultables mais on peut ajouter une logique ici
  return true;
}

/**
 * Modifiez la mÃ©thode changeDiscussion pour gÃ©rer les discussions expirÃ©es
 */
changeDiscussion(discussionId: number, index: number) {
  this.loadingSpinnerService.setLoading(true);
  
  const selectedDiscussion = this.activeDiscussions[index];
  
  // VÃ©rifier si la discussion est expirÃ©e et afficher un avertissement
  if (this.isDiscussionExpired(selectedDiscussion)) {
    console.warn('Cette discussion a plus d\'une heure et pourrait Ãªtre archivÃ©e');
    // Optionnel: afficher une notification Ã  l'utilisateur
  }

  this.signalRService.sendDiscussionIdEvent(discussionId);
  this.activeDiscussions.forEach((item, i) => {
    console.log(item.selected = (i === index));
    item.selected = (i === index);
  });
  
  this.selectedItemIndex = index;
  this.activeDiscussionId = discussionId;
  
  this.router.navigate(['/pages/chat/discussion/', discussionId]).then(success => {
    if (!success) {
      this.signalRService.disconnectFromDiscussion(discussionId.toString());
    }
  });
}

/**
 * MÃ©thode pour mettre Ã  jour pÃ©riodiquement le statut des discussions
 */
ngOnInit(): void {
  // ... votre code existant ...
  
  // Mettre Ã  jour le statut des discussions toutes les minutes
  setInterval(() => {
    this.updateDiscussionStatuses();
  }, 60000); // 60 secondes
}

/**
 * Met Ã  jour le statut de toutes les discussions
 */
private updateDiscussionStatuses(): void {
  // Pas besoin de logique spÃ©ciale, le template se mettra Ã  jour automatiquement
  // grÃ¢ce Ã  la mÃ©thode isDiscussionExpired() qui recalcule Ã  chaque appel
}






// Dans ChatConversationListComponent, modifiez la mÃ©thode createDiscussion:

createDiscussion() {
  this.signalRService.createDiscussion("new discussion").then(discussionId => {
    if (discussionId !== -1) {
      // CrÃ©er le nouvel objet Discussion
      const newDiscussion = new Discussion(
        discussionId, 
        "new discussion", 
        '', 
        new Date(), 
        new Date(), 
        true, 
        '', 
        0, 
        0, 
        0, 
        0, 
        null, 
        false, 
        0
      );
      
      // Mettre Ã  jour les propriÃ©tÃ©s du composant
      this.newDiscussion.id = discussionId;
      this.newDiscussion.name = "new discussion";
      
      // Ajouter automatiquement Ã  la liste des discussions actives
      this.activeDiscussions.unshift(newDiscussion); // Ajouter au dÃ©but de la liste
      
      // Mettre Ã  jour allDiscussions aussi si nÃ©cessaire
      this.allDiscussions.unshift(newDiscussion);
      
      // Optionnel: naviguer automatiquement vers la nouvelle discussion
      this.changeDiscussion(discussionId, 0);
    }
  }).catch(error => {
    console.error('Erreur lors de la crÃ©ation de la discussion:', error);
  });
}

// Alternative: Si vous prÃ©fÃ©rez recharger toute la liste
createDiscussionWithReload() {
  this.signalRService.createDiscussion("new discussion").then(discussionId => {
    if (discussionId !== -1) {
      // Recharger complÃ¨tement la liste des discussions
      this.loadAllDiscussions();
      
      // Optionnel: sÃ©lectionner automatiquement la nouvelle discussion
      setTimeout(() => {
        const newIndex = this.activeDiscussions.findIndex(d => d.id === discussionId);
        if (newIndex !== -1) {
          this.changeDiscussion(discussionId, newIndex);
        }
      }, 500);
    }
  });
}

