import { NewDropdown } from '@component-studio/ui';
import AvailableItem from 'components/Form/AvailableItem';
import IconButton from 'components/IconButton';
import Modal from 'components/Modal';
import ModalLayout from 'components/ModalLayout';
import { OBJECT_TYPE_ACTOR } from 'constants/objectTypes';
import {
  PRODUCT_TYPES,
  PRODUCT_TYPE_MANDATE,
  PRODUCT_TYPE_SINGLE,
  PRODUCT_TYPE_SUBFUND,
  PRODUCT_TYPE_UMBRELLA,
} from 'constants/productObjects';
import {
  PROJECT_MODEL_TYPE_MASS_UPDATE,
  PROJECT_MODEL_TYPE_MASS_UPDATE_ACTOR,
} from 'constants/projectModel';
import FormSubcategory from 'pages/Project/components/OperationalItems/components/FormSubcategory';
import { lazy, useEffect, useMemo, useState, Suspense } from 'react';
import { FormattedMessage } from 'react-intl';
import { Grid, LoadingIndicatorWithPosition } from 'styles';
import { useFetchMuActors } from 'redux/entities/massUpdateTemplates/hooks.js';

import FormCategory from 'pages/Project/components/OperationalItems/components/FormCategory';
import Style from './MassUpdateProductSelection.style';

const ConfirmationDialog = lazy(() =>
  import(/* webpackChunkName: "ConfirmationDialog" */ 'components/ConfirmationDialog'),
);

export type OwnPropsType = {
  taskId: number,
  onCloseClick: () => void,
  downloadMassUpdateTemplate: (taskId: number, productId: string[]) => void,
  project: ProjectTypeForUi,
  umbrellas: UmbrellasByIdStateType,
};

export type MapDispatchToPropsType = {
  fetchProducts: (
    productType: ?string,
    umbrellaId: ?string,
    searchByUmbrella: boolean,
    actorUid: ?string,
    actorTeamCd: ?string,
    mgmtCompLbl: ?string,
    domiciliationCtry: ?string,
    umbNameLbl: ?string,
  ) => void,
  fetchFilteredMuProducts: (
    productType: ?string,
    umbrellaId: ?string,
    searchByUmbrella: boolean,
    actorUid: ?string,
    actorTeamCd: ?string,
    mgmtCompLbl: ?string,
    domiciliationCtry: ?string,
    umbNameLbl: ?string,
  ) => void,
  fetchUmbrellas: () => void,
};

export type MapStateToPropsType = {
  products: ProductType[],
  filteredMuProducts: ProductType[],
  token: ?string,
  isLoading: ?boolean,
};

export type PropsType = OwnPropsType &
  MapDispatchToPropsType &
  MapStateToPropsType & { formik: FormikPropsType };

export const filterProducts = (products: ProductType[], filter: string): VisibleProductsType => {
  return products
    .filter(
      product =>
        product.official_name && product.official_name.toLowerCase().includes(filter.toLowerCase()),
    )
    .map(product => ({ id: product.id, name: product.official_name }))
    .sort((a, b) => (a.name && b.name && a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1));
};

export const filterUmbrellas = (
  umbrellas: UmbrellasByIdStateType,
  filter: string,
): VisibleProductsType =>
  Object.keys(umbrellas)
    .filter(umbrellaId => umbrellas[umbrellaId].name.toLowerCase().includes(filter.toLowerCase()))
    .map(umbrellaId => ({ id: umbrellaId, name: umbrellas[umbrellaId].name }))
    .sort((a, b) => (a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1));

const MassUpdateProductSelection = ({
  taskId,
  token,
  onCloseClick,
  downloadMassUpdateTemplate,
  fetchProducts,
  fetchFilteredMuProducts,
  fetchUmbrellas,
  products,
  filteredMuProducts,
  umbrellas,
  formik,
  project,
  isLoading,
}: PropsType) => {
  const [filter, setFilter] = useState<string>('');
  const [actorNames, setActorNames] = useState<Array<{ value: string, label: string }>>([]);
  const [actorsTeams, setActorsTeams] = useState<Array<{ value: string, label: string }>>([]);
  const [mgmtCompanies, setMgmtCompanies] = useState<Array<{ value: string, label: string }>>([]);
  const [countries, setCountries] = useState<Array<{ value: string, label: string }>>([]);
  const [umbrellaNames, setUmbrellaNames] = useState<Array<{ value: string, label: string }>>([]);
  
  const [selectedActor, setSelectedActor] = useState<{ value: string, label: string }>({ value: '', label: '' });
  const [selectedTeam, setSelectedTeam] = useState<{ value: string, label: string }>({ value: '', label: '' });
  const [selectedMgmtComp, setSelectedMgmtComp] = useState<{ value: string, label: string }>({ value: '', label: '' });
  const [selectedDomCountry, setSelectedDomCountry] = useState<{ value: string, label: string }>({ value: '', label: '' });
  const [selectedUmbName, setSelectedUmbName] = useState<{ value: string, label: string }>({ value: '', label: '' });
  
  const [productsFiltered, setProductsFiltered] = useState<Array<ProductType>>([]);
  const { value: actors } = useFetchMuActors(token, false, null) || {};
  
  // Extract unique values for dropdowns from actors data
  useEffect(
    () => {
      if (actors) {
        // Extract actor names
        setActorNames(
          actors.map(actor => {
            return { value: actor.id, label: `${actor.actor_name} ${actor.actor_first_name}` };
          }),
        );
        
        // Extract unique teams
        const uniqueTeams = [...new Set(actors.map(actor => actor.team_chg_lbl).filter(Boolean))];
        setActorsTeams(
          uniqueTeams.map(team => ({ value: team, label: team }))
        );
      }
    },
    [actors],
  );

  // Extract unique values for new filters from products
  useEffect(
    () => {
      const allProducts = filteredMuProducts.length > 0 ? filteredMuProducts : products;
      
      if (allProducts && allProducts.length > 0) {
        // Extract unique management companies
        const uniqueMgmtComps = [...new Set(
          allProducts
            .map(product => product.mgmt_comp_lbl)
            .filter(Boolean)
        )].sort();
        setMgmtCompanies(
          uniqueMgmtComps.map(comp => ({ value: comp, label: comp }))
        );
        
        // Extract unique countries
        const uniqueCountries = [...new Set(
          allProducts
            .map(product => product.domiciliation_ctry)
            .filter(Boolean)
        )].sort();
        setCountries(
          uniqueCountries.map(country => ({ value: country, label: country }))
        );
        
        // Extract unique umbrella names
        const uniqueUmbNames = [...new Set(
          allProducts
            .map(product => product.umb_name_lbl)
            .filter(Boolean)
        )].sort();
        setUmbrellaNames(
          uniqueUmbNames.map(umb => ({ value: umb, label: umb }))
        );
      }
    },
    [products, filteredMuProducts],
  );
  
  useEffect(
    () => {
      if (filter) {
        setProductsFiltered(
          filteredMuProducts
            .sort((a, b) =>
              a.official_name.toLowerCase() > b.official_name.toLowerCase() ? 1 : -1,
            )
            .filter(product => product.official_name && product.official_name.includes(filter)),
        );
      } else {
        setProductsFiltered(
          filteredMuProducts.sort((a, b) =>
            a.official_name.toLowerCase() > b.official_name.toLowerCase() ? 1 : -1,
          ),
        );
      }
    },
    [filter, filteredMuProducts],
  );

  // Fetch products based on all selected filters (AND logic)
  useEffect(
    () => {
      const [selectedActorLastName, selectedActorFirstName] = selectedActor
        ? selectedActor.label.split(' ')
        : ['', ''];
      const filteredActorsByName =
        actors &&
        actors.filter(
          actor =>
            actor.actor_first_name === selectedActorFirstName &&
            actor.actor_name === selectedActorLastName,
        );
      const actorUid =
        filteredActorsByName && filteredActorsByName.length > 0 ? filteredActorsByName[0].uid : '';
      const filteredActorsByTeam =
        actors && actors.filter(actor => selectedTeam && selectedTeam.label === actor.team_chg_lbl);
      const teamCd =
        filteredActorsByTeam && filteredActorsByTeam.length > 0
          ? filteredActorsByTeam[0].team_chg_cd
          : '';
      
      // Get values for new filters
      const mgmtCompLbl = selectedMgmtComp && selectedMgmtComp.value ? selectedMgmtComp.value : '';
      const domiciliationCtry = selectedDomCountry && selectedDomCountry.value ? selectedDomCountry.value : '';
      const umbNameLbl = selectedUmbName && selectedUmbName.value ? selectedUmbName.value : '';
      
      const isAnyFilterSelected =
        (actorUid && actorUid !== '') || 
        (teamCd && teamCd !== '') ||
        (mgmtCompLbl && mgmtCompLbl !== '') ||
        (domiciliationCtry && domiciliationCtry !== '') ||
        (umbNameLbl && umbNameLbl !== '');
      
      if (
        project.projectModel &&
        project.productType &&
        project.projectModel.name &&
        project.projectModel.name === PROJECT_MODEL_TYPE_MASS_UPDATE_ACTOR
      ) {
        isAnyFilterSelected
          ? fetchFilteredMuProducts(null, null, false, actorUid, teamCd, mgmtCompLbl, domiciliationCtry, umbNameLbl)
          : fetchProducts(null, null, false, '', '', '', '', '');
      } else {
        switch (project.productType) {
          case PRODUCT_TYPE_SINGLE:
            isAnyFilterSelected
              ? fetchFilteredMuProducts(
                  PRODUCT_TYPES[PRODUCT_TYPE_SINGLE].smartgpsValue,
                  null,
                  false,
                  actorUid,
                  teamCd,
                  mgmtCompLbl,
                  domiciliationCtry,
                  umbNameLbl,
                )
              : fetchProducts(PRODUCT_TYPES[PRODUCT_TYPE_SINGLE].smartgpsValue, null, false, '', '', '', '', '');
            break;
          case PRODUCT_TYPE_SUBFUND:
            isAnyFilterSelected
              ? fetchFilteredMuProducts(
                  PRODUCT_TYPES[PRODUCT_TYPE_SUBFUND].smartgpsValue,
                  null,
                  false,
                  actorUid,
                  teamCd,
                  mgmtCompLbl,
                  domiciliationCtry,
                  umbNameLbl,
                )
              : fetchProducts(PRODUCT_TYPES[PRODUCT_TYPE_SUBFUND].smartgpsValue, null, false, '', '', '', '', '');
            break;
          case PRODUCT_TYPE_MANDATE:
            isAnyFilterSelected
              ? fetchFilteredMuProducts(
                  PRODUCT_TYPES[PRODUCT_TYPE_MANDATE].smartgpsValue,
                  null,
                  false,
                  actorUid,
                  teamCd,
                  mgmtCompLbl,
                  domiciliationCtry,
                  umbNameLbl,
                )
              : fetchProducts(PRODUCT_TYPES[PRODUCT_TYPE_MANDATE].smartgpsValue, null, false, '', '', '', '', '');
            break;
          case PRODUCT_TYPE_UMBRELLA:
            fetchUmbrellas();
            break;
          default:
            break;
        }
      }
    },
    [
      actors,
      fetchFilteredMuProducts,
      fetchProducts,
      fetchUmbrellas,
      project.productType,
      project.projectModel,
      selectedActor,
      selectedTeam,
      selectedMgmtComp,
      selectedDomCountry,
      selectedUmbName,
    ],
  );

  const visibleProducts = useMemo(
    () =>
      project.productType === PRODUCT_TYPE_UMBRELLA
        ? filterUmbrellas(umbrellas, filter)
        : filterProducts(products, filter),
    [project.productType, products, umbrellas, filter],
  );

  const selectedItems = formik.values.selectedItems;

  const isChecked = (product: VisibleProductType) => {
    return product.id in selectedItems;
  };

  const removeItem = (product: VisibleProductType) => {
    delete selectedItems[product.id];
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const removeItemById = (id: string) => {
    delete selectedItems[id];
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const addItem = (product: VisibleProductType) => {
    selectedItems[product.id] = product.name;
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const onItemClick = (product: VisibleProductType) => {
    if (isChecked(product)) {
      removeItem(product);
    } else {
      addItem(product);
    }
  };

  const removeAll = () => {
    formik.setFieldValue('selectedItems', {});
  };

  const selectAll = () => {
    filteredMuProducts.length > 0
      ? filteredMuProducts.forEach(product => {
          selectedItems[product.id] = product.name;
        })
      : visibleProducts.forEach(product => {
          selectedItems[product.id] = product.name;
        });
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const isFilterSelected =
    (selectedActor && selectedActor.label !== '') || 
    (selectedTeam && selectedTeam.label !== '') ||
    (selectedMgmtComp && selectedMgmtComp.label !== '') ||
    (selectedDomCountry && selectedDomCountry.label !== '') ||
    (selectedUmbName && selectedUmbName.label !== '');
    
  const massUpdateModalTitle =
    project.projectModel &&
    project.projectModel.type &&
    project.projectModel.name &&
    project.projectModel.type === PROJECT_MODEL_TYPE_MASS_UPDATE &&
    project.projectModel.name === PROJECT_MODEL_TYPE_MASS_UPDATE_ACTOR
      ? 'Mass Update Products Selection'
      : `Mass Update Products Selection (${project.productType})`;
  
  return (
    <ModalLayout
      title={massUpdateModalTitle}
      description="Select the products to fill the Mass Update Template"
      onCancel={onCloseClick}
      onConfirm={() => {
        downloadMassUpdateTemplate(taskId, Object.keys(selectedItems));
        onCloseClick();
      }}
    >
      <Modal
        width={Grid(96)}
        height={Grid(44)}
        isOpen={isFilterSelected && !isLoading && filteredMuProducts.length <= 0}
        onCloseClick={() => {
          setSelectedActor({ value: '', label: '' });
          setSelectedTeam({ value: '', label: '' });
          setSelectedMgmtComp({ value: '', label: '' });
          setSelectedDomCountry({ value: '', label: '' });
          setSelectedUmbName({ value: '', label: '' });
        }}
      >
        <Suspense fallback={<LoadingIndicatorWithPosition />}>
          <ConfirmationDialog
            title={<FormattedMessage id="MU_PRODUCTS_SELECTION.NO_PRODUCTS" />}
            isConfirmButtonHidden
            isCancelButtonHidden
          />
        </Suspense>
      </Modal>
      {project.projectModel && project.projectModel.name.includes(OBJECT_TYPE_ACTOR) && (
        <FormCategory categoryLabel="MASSUPDATE_FILTERS">
          <FormSubcategory subcategoryLabel={'Teams'}>
            <NewDropdown
              options={actorsTeams}
              isClearable
              value={selectedTeam}
              onChange={(selectedOption) => {
                setSelectedTeam(selectedOption || { value: '', label: '' });
              }}
            />
          </FormSubcategory>
          <FormSubcategory subcategoryLabel={'Actor Names'}>
            <NewDropdown
              key="actor"
              isClearable
              value={selectedActor}
              options={actorNames}
              onChange={(selectedOption) => {
                setSelectedActor(selectedOption || { value: '', label: '' });
              }}
            />
          </FormSubcategory>
          <FormSubcategory subcategoryLabel={'Management Company'}>
            <NewDropdown
              key="mgmt_comp"
              isClearable
              value={selectedMgmtComp}
              options={mgmtCompanies}
              onChange={(selectedOption) => {
                setSelectedMgmtComp(selectedOption || { value: '', label: '' });
              }}
            />
          </FormSubcategory>
          <FormSubcategory subcategoryLabel={'Domiciliation Country'}>
            <NewDropdown
              key="dom_country"
              isClearable
              value={selectedDomCountry}
              options={countries}
              onChange={(selectedOption) => {
                setSelectedDomCountry(selectedOption || { value: '', label: '' });
              }}
            />
          </FormSubcategory>
          <FormSubcategory subcategoryLabel={'Umbrella Name'}>
            <NewDropdown
              key="umb_name"
              isClearable
              value={selectedUmbName}
              options={umbrellaNames}
              onChange={(selectedOption) => {
                setSelectedUmbName(selectedOption || { value: '', label: '' });
              }}
            />
          </FormSubcategory>
        </FormCategory>
      )}
      <Style.Container>
        <FormSubcategory subcategoryLabel={'Products'}>
          <Style.FilterInputWithPlaceholder
            filter={{ id: filter, value: filter }}
            onChange={(value: string) => {
              setFilter(value);
            }}
          />
        </FormSubcategory>
        <Style.AvailableList>
          {isFilterSelected ? (
            productsFiltered.length <= 0 ? (
              <LoadingIndicatorWithPosition />
            ) : (
              productsFiltered.map(product => (
                <AvailableItem
                  key={product.id}
                  columnName={product.official_name}
                  onClick={() => onItemClick(product)}
                  isChecked={isChecked(product)}
                />
              ))
            )
          ) : (
            visibleProducts.length > 0 &&
            visibleProducts.map(product => (
              <AvailableItem
                key={product.id}
                columnName={product.name}
                onClick={() => onItemClick(product)}
                isChecked={isChecked(product)}
              />
            ))
          )}
        </Style.AvailableList>
      </Style.Container>

      <Style.ListSeparatorContainer className="listSeparator">
        <IconButton onClick={() => selectAll()}>
          <Style.SeparatorIcon slug="arrows-arrow-right" />
        </IconButton>
        <IconButton onClick={() => removeAll()}>
          <Style.SeparatorIcon slug="arrows-arrow-left" />
        </IconButton>
      </Style.ListSeparatorContainer>

      <FormSubcategory
        subcategoryLabel={`Selection ${Object.keys(selectedItems).length}`}
      >
        <Style.SelectedItems>
          {Object.keys(selectedItems).map(id => (
            <Style.SelectedItem key={id}>
              {selectedItems[id]}
              <IconButton onClick={() => removeItemById(id)}>
                <Style.RemoveIndicator slug="close" size={10} />
              </IconButton>
            </Style.SelectedItem>
          ))}
        </Style.SelectedItems>
      </FormSubcategory>
    </ModalLayout>
  );
};

export default MassUpdateProductSelection;
