D’accord — je vais te renvoyer un fichier complet get_mass_update_template.py avec le cas spécifique Upload Specific Fees template ajouté dans le même style que votre code (NamedStyle, Protection, DataValidation, etc.), sans casser le flux générique existant.

⚠️ Comme je n’ai pas ton fichier “texte” exact (uniquement des captures), je garde la même structure et les mêmes imports vus dans tes screens, et j’ajoute le minimum :

une fonction create_specific_fees_template_workbook(adl_fees_data) qui génère un workbook complet

dans retrieve_mass_update_template(...) : un if task.name == 'Upload Specific Fees template' qui bypass le template générique et retourne le workbook spécifique

toutes les colonnes verrouillées, sauf New ADL in et New ADL out (déverrouillées + validation numérique “stop”)



---

✅ Fichier complet : src/util/mass_update/get_mass_update_template.py

> Remplace ton fichier par celui-ci, ou copie uniquement les parties “SPECIFIC FEES” si tu préfères patcher.



import logging

import openpyxl
from context_managers import SessionCriticalActionManager
from io import BytesIO
from openpyxl.cell import WriteOnlyCell
from openpyxl.comments import Comment
from openpyxl.styles import Alignment, Border, Font, NamedStyle, PatternFill, Protection, Side
from openpyxl.styles.numbers import FORMAT_DATE_XLSX14, FORMAT_NUMBER, FORMAT_NUMBER_COMMA_SEPARATED1, FORMAT_TEXT
from openpyxl.utils import get_column_letter, quote_sheetname
from openpyxl.workbook import Workbook
from openpyxl.workbook.defined_name import DefinedName
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.worksheet.worksheet import Worksheet

from client import cos_read_file, get_fields_metadata, get_products_initial_data, get_adl_fees_data
from config import DEV_TEAM_EMAILS
from constants import (
    CREATE_ACTION,
    DATE_FIELD_TYPE,
    DECIMAL_FIELD_TYPE,
    DELETE_ACTION,
    FLAG_FIELD_TYPE,
    INTEGER_FIELD_TYPE,
    MODIFY_ACTION,
    PERCENTAGE_FIELD_TYPE,
    STRING_FIELD_TYPE,
    TEXT_FIELD_TYPE,
    UNUSED_ACTION,
)
from constants.mass_update import (
    WS_DATA_NAME,
    WS_FIELD_VALUE_PREFIX,
    WS_INITIAL_DATA_NAME,
    WS_LOOKUP_DATA_NAME,
    WS_PARENTS_NAME,
    WS_PRODUCTS_NAME,
)
from db import db
from util.business_rules import (
    CONDITION_OPERATOR_GREATER_THAN,
    CONDITION_OPERATOR_LESS_THAN,
    get_high_boundary_for_static_value_comparison_business_rule,
    get_low_boundary_for_static_value_comparison_business_rule,
)
from util.errors import TaskWithoutMassUpdateTemplate
from util.field_values import retrieve_field_values
from util.mass_update.constants import NULL_MASS_UPDATE_CONFIGURATION_FILTER
from util.product_initial_data import expand_product_initial_data, get_products_with_entities


# ============================================================
# Existing styles constants (as in your screenshots)
# ============================================================
FONT_NAME = "Verdana"
LIGHT_GREY_COLOR = "C0C0C0"
PRODUCT_EVEN_COLOR = "CCFFFF"
PRODUCT_ODD_COLOR = "33CCCC"
PRODUCT_CREATE_COLOR = "33DDCC"
DEFAULT_VALUE_COLOR = "00FFCC00"

TITLE_STYLE = "style_title"
PRODUCT_CREATE_STYLE = "style_product_create"
PRODUCT_EVEN_STYLE = "style_product_even"
PRODUCT_ODD_STYLE = "style_product_odd"
PRODUCT_STYLES = [PRODUCT_EVEN_STYLE, PRODUCT_ODD_STYLE]

DEFAULT_SIDE = Side(style="thin", color=LIGHT_GREY_COLOR)
DEFAULT_BORDER = Border(
    left=DEFAULT_SIDE, right=DEFAULT_SIDE, top=DEFAULT_SIDE, bottom=DEFAULT_SIDE
)
TITLE_FONT = Font(name=FONT_NAME, size=11, bold=True)
DATA_FONT = Font(name=FONT_NAME, size=11)

COUNT_EXTRA_ROWS_FOR_CREATION = 100


def create_named_style(wb: Workbook):
    """create named styles used across the workbook"""

    # Title Style
    ns = NamedStyle(name=TITLE_STYLE)
    ns.font = TITLE_FONT
    ns.fill = PatternFill(fgColor=LIGHT_GREY_COLOR, fill_type="solid")
    ns.border = DEFAULT_BORDER
    ns.protection = Protection(locked=True)
    ns.alignment = Alignment(wrap_text=True)
    wb.add_named_style(ns)

    # Product-even data row
    ns = NamedStyle(name=PRODUCT_EVEN_STYLE)
    ns.font = DATA_FONT
    ns.fill = PatternFill(fgColor=PRODUCT_EVEN_COLOR, patternType="solid")
    ns.protection = Protection(locked=False)
    ns.border = DEFAULT_BORDER
    wb.add_named_style(ns)

    # Product-odd data row
    ns = NamedStyle(name=PRODUCT_ODD_STYLE)
    ns.font = DATA_FONT
    ns.fill = PatternFill(fgColor=PRODUCT_ODD_COLOR, patternType="solid")
    ns.protection = Protection(locked=False)
    ns.border = DEFAULT_BORDER
    wb.add_named_style(ns)

    # Additional data row (Create)
    ns = NamedStyle(name=PRODUCT_CREATE_STYLE)
    ns.font = DATA_FONT
    ns.fill = PatternFill(fgColor=PRODUCT_CREATE_COLOR, patternType="solid")
    ns.protection = Protection(locked=False)
    ns.border = DEFAULT_BORDER
    wb.add_named_style(ns)


def _get_field_value_worksheet_name(field_values_type):
    return WS_FIELD_VALUE_PREFIX + field_values_type


def create_reference_worksheet(wb: Workbook, sheetname, tablename, reference_dict):
    """Create a reference worksheet for further lookups."""
    ws: Worksheet = wb.create_sheet(sheetname)

    ws.cell(1, 1, "NAME").style = TITLE_STYLE
    ws.cell(1, 2, "ID").style = TITLE_STYLE

    # protection + hide
    ws.sheet_state = "hidden"
    ws.protection.enable()

    if len(reference_dict) == 0:
        return

    max_column_idx = 2
    child_max_row_idx = 0
    ref_max_row_idx = 1

    for row_idx, (ref_id, ref_details) in enumerate(reference_dict.items(), start=2):
        ws.append([ref_details.get("name"), ref_id])
        ref_max_row_idx = max(ref_max_row_idx, row_idx)

    for row_idx, (ref_id, ref_details) in enumerate(reference_dict.items(), start=2):
        if ref_details.get("children"):
            max_column_idx += 1
            ws.cell(1, max_column_idx, ref_details.get("name"))
            for child_row_idx, child in enumerate(ref_details.get("children"), start=2):
                ws.cell(child_row_idx, max_column_idx, child)
                child_max_row_idx = max(child_max_row_idx, child_row_idx)

    # create table
    max_row_idx = max(ref_max_row_idx, child_max_row_idx)
    max_column_letter = get_column_letter(max_column_idx)
    table = Table(
        displayName=tablename,
        name=tablename,
        ref=f"A1:{max_column_letter}{max_row_idx}",
        tableStyleInfo=TableStyleInfo(name="TableStyleLight3"),
    )
    ws.add_table(table)

    # children exist ?
    if max_column_idx > 2:
        dn_name_match = f"_{tablename}Match"
        defn_match = DefinedName(
            dn_name_match,
            attr_text=f"MATCH(INDIRECT(\"RC[-1]\",0),{tablename}[[#Headers]],0)",
            function=True,
        )
        wb.defined_names[dn_name_match] = defn_match

        dn_name_children = f"_{tablename}Children"
        defn_children = DefinedName(
            dn_name_children,
            attr_text=f"INDEX({tablename}[[#All]],0,{{{dn_name_match}}})",
        )
        wb.defined_names[dn_name_children] = defn_children

        dn_name_children_filtered = f"_{tablename}ChildrenFiltered"
        defn_children_filtered = DefinedName(
            dn_name_children_filtered,
            attr_text=f"INDEX({dn_name_children},2,1):INDEX({dn_name_children},COUNTA({dn_name_children}))",
        )
        wb.defined_names[dn_name_children_filtered] = defn_children_filtered

    dn_name = f"_{tablename}Name"
    defn_name = DefinedName(
        dn_name,
        attr_text=f"{tablename}[NAME]",
    )
    wb.defined_names[dn_name] = defn_name


def create_field_values_worksheets(wb: Workbook, field_metadatas):
    """create excel table for field_metadata linked to a list of value"""

    field_values_items_by_type = retrieve_field_values(field_metadatas)

    for field_metadata in field_metadatas:
        field_values = field_values_items_by_type.get(field_metadata["field_values_type"])
        if field_values:
            for field_value in field_values:
                if field_value["code"] == field_metadata.get("default_value"):
                    field_metadata.update({"default_value": field_value.get("label_en")})
                    break

    for field_values_type in field_values_items_by_type.keys():
        ref_dict = {
            field_value["code"]: {
                "name": field_value["label_en"] if field_value["is_active"] else field_value["label_en"]
            }
            for field_value in field_values_items_by_type[field_values_type]
        }
        create_reference_worksheet(
            wb,
            _get_field_value_worksheet_name(field_values_type),
            field_values_type,
            ref_dict,
        )


def create_data_validators(wb: Workbook, mass_update_template, field_metadatas_dict):
    """data validators and formatting"""
    ws: Worksheet = wb[WS_DATA_NAME]
    data_validators_dict = {}

    # data-validators on action column
    data_validator = DataValidation(
        "list",
        formula1=(
            f'"{MODIFY_ACTION},{DELETE_ACTION}"'
            if mass_update_template.allow_delete_action
            else f'"{MODIFY_ACTION}"'
        ),
        allow_blank=False,
    )
    data_validator.errorStyle = "stop"
    data_validator.showErrorMessage = True
    data_validators_dict[MODIFY_ACTION] = data_validator

    data_validator = DataValidation(
        "list",
        formula1=(
            f'"{UNUSED_ACTION},{CREATE_ACTION}"'
            if mass_update_template.allow_create_action
            else f'"{UNUSED_ACTION}"'
        ),
        allow_blank=False,
    )
    data_validator.errorStyle = "stop"
    data_validator.showErrorMessage = True
    data_validators_dict[UNUSED_ACTION] = data_validator

    for mass_update_template_field in mass_update_template.fields:
        field_metadata = field_metadatas_dict.get(mass_update_template_field.field_id)
        if not field_metadata:
            continue

        def create_text_data_validator():
            if field_metadata.get("fixed_size"):
                return DataValidation(
                    "textLength",
                    formula1=field_metadata["fixed_size"],
                    operator="equal",
                )
            if field_metadata.get("max_length"):
                return DataValidation(
                    "textLength",
                    formula1=0,
                    formula2=field_metadata["max_length"],
                    operator="between",
                )
            return None

        def create_value_comparison_data_validator(data_validator_type):
            low = get_low_boundary_for_static_value_comparison_business_rule(field_metadata)
            high = get_high_boundary_for_static_value_comparison_business_rule(field_metadata)

            if low and high:
                return DataValidation(
                    data_validator_type,
                    formula1=low["condition_value"],
                    formula2=high["condition_value"],
                    operator="between",
                )
            elif low:
                return DataValidation(
                    data_validator_type,
                    formula1=low["condition_value"],
                    operator=(
                        "greaterThan"
                        if low["condition_operator"] == CONDITION_OPERATOR_GREATER_THAN
                        else "greaterThanOrEqual"
                    ),
                )
            elif high:
                return DataValidation(
                    data_validator_type,
                    formula1=high["condition_value"],
                    operator=(
                        "lessThan"
                        if high["condition_operator"] == CONDITION_OPERATOR_LESS_THAN
                        else "lessThanOrEqual"
                    ),
                )
            return None

        data_validator = None
        if field_metadata["type"] in [STRING_FIELD_TYPE, TEXT_FIELD_TYPE]:
            data_validator = create_text_data_validator()
        if field_metadata["type"] == DATE_FIELD_TYPE:
            data_validator = DataValidation("date")
        if field_metadata["type"] == INTEGER_FIELD_TYPE:
            data_validator = create_value_comparison_data_validator("whole")
        if field_metadata["type"] == DECIMAL_FIELD_TYPE:
            data_validator = create_value_comparison_data_validator("decimal")
        if field_metadata["type"] == PERCENTAGE_FIELD_TYPE:
            data_validator = create_value_comparison_data_validator("decimal")
        if field_metadata["type"] == FLAG_FIELD_TYPE:
            data_validator = DataValidation("list", formula1='"Y,N"', allow_blank=True)
        if field_metadata.get("field_values_type"):
            field_values_type = field_metadata["field_values_type"]
            defined_name = f"_{field_values_type}Name"
            data_validator = DataValidation("list", formula1=defined_name)

        if data_validator:
            data_validator.errorStyle = "stop"
            data_validator.showErrorMessage = True
            data_validator.allow_blank = not field_metadata.get("is_mandatory", False)
            data_validators_dict[field_metadata["id"]] = data_validator

    for data_validator in data_validators_dict.values():
        ws.add_data_validation(data_validator)

    return data_validators_dict


def create_data_worksheets(wb: Workbook, mass_update_template, field_metadatas_dict):
    """create a new data worksheet"""
    ws: Worksheet = wb.create_sheet(WS_DATA_NAME)

    ws.column_dimensions["A"].width = 10
    ws.freeze_panes = "F2"

    ws.protection.enabled = True
    ws.protection.selectLockedCells = True
    ws.protection.formatColumns = False

    ws.cell(1, 1, mass_update_template.data_action_type_column).style = TITLE_STYLE
    ws.cell(1, 2, mass_update_template.product_id_column).style = TITLE_STYLE
    ws.cell(1, 3, mass_update_template.product_official_name_column).style = TITLE_STYLE

    if mass_update_template.is_parent_id_column_required():
        ws.cell(1, 4, mass_update_template.parent_entity_id_column).style = TITLE_STYLE
    else:
        ws.column_dimensions["D"].hidden = True

    if mass_update_template.is_entity_id_column_required():
        ws.cell(1, 5, mass_update_template.entity_id_column).style = TITLE_STYLE
    else:
        ws.column_dimensions["E"].hidden = True

    for column_idx, mass_update_template_field in enumerate(mass_update_template.fields, 6):
        field_metadata = field_metadatas_dict.get(mass_update_template_field.field_id)
        cell = ws.cell(1, column_idx, mass_update_template_field.column_name)
        cell.style = TITLE_STYLE
        if field_metadata:
            cell.comment = Comment(
                f'{field_metadata.get("id")} - {field_metadata.get("category")} - {field_metadata.get("subcategory")}',
                "FLOWR",
            )

    row = ws.row_dimensions[1]
    row.number_format = FORMAT_TEXT

    ws_initial_data = wb.copy_worksheet(ws)
    ws_initial_data.title = WS_INITIAL_DATA_NAME
    ws_initial_data.sheet_state = "hidden"
    ws_initial_data.protection.enable()

    ws_lookup_data = wb.copy_worksheet(ws)
    ws_lookup_data.title = WS_LOOKUP_DATA_NAME
    ws_lookup_data.sheet_state = "hidden"
    ws_lookup_data.protection.enable()

    data_validators_dict = create_data_validators(wb, mass_update_template, field_metadatas_dict)
    return data_validators_dict


def populate_data_worksheets(
    wb: Workbook,
    project,
    mass_update_template,
    field_metadatas_dict,
    data_validators_dict,
    products_entities_dict,
):
    """populate the data worksheet with products initial data"""

    if not (products_entities_dict and mass_update_template.fields):
        return

    def write_rows(
        row_idx,
        product_id,
        action=UNUSED_ACTION,
        parent_id=None,
        object_id=None,
        product_initial_data_by_field=None,
        style=PRODUCT_EVEN_STYLE,
    ):
        if product_initial_data_by_field is None:
            product_initial_data_by_field = {}

        ws: Worksheet = wb[WS_DATA_NAME]

        def _get_action_cell(ws):
            cell: WriteOnlyCell = WriteOnlyCell(ws, action)
            cell.style = style
            data_validators_dict[action].add(cell)
            return cell

        def get_product_id_cell():
            cell: WriteOnlyCell = WriteOnlyCell(ws, product_id)
            cell.style = style
            cell.protection = Protection(locked=True)
            return cell

        def get_product_name_cell():
            cell: WriteOnlyCell = WriteOnlyCell(
                ws, products_entities_dict[product_id].get("official_name")
            )
            cell.style = style
            cell.protection = Protection(locked=True)
            return cell

        def get_parent_name_cell():
            parent_name = products_entities_dict[product_id]["entities"].get(
                (parent_id, mass_update_template.parent_entity_type)
            )
            cell: WriteOnlyCell = WriteOnlyCell(ws, parent_name)
            cell.style = style
            cell.protection = Protection(locked=True if action == MODIFY_ACTION else False)
            return cell

        def get_entity_cell():
            cell: WriteOnlyCell = WriteOnlyCell(ws, str(object_id) if object_id else None)
            cell.style = style
            cell.protection = Protection(locked=True)
            return cell

        def get_data_cell(field_metadata, mass_update_template_field, product_initial_data):
            attr_value = "value_label" if field_metadata.get("field_values_type") else "value"
            value = (
                product_initial_data.get(attr_value)
                if product_initial_data and product_initial_data.get(attr_value)
                else None
            )

            comment = None
            if not value:
                value = field_metadata.get("default_value")
                comment = Comment("prefilled with default value", "FLOWR") if value else None

            cell: WriteOnlyCell = WriteOnlyCell(ws, value)
            cell.style = style
            cell.border = DEFAULT_BORDER
            cell.comment = comment

            cell.protection = Protection(
                locked=False if mass_update_template_field.allow_changes or action == UNUSED_ACTION else True
            )

            if field_metadata["type"] == DATE_FIELD_TYPE:
                cell.number_format = FORMAT_DATE_XLSX14
            if field_metadata["type"] == INTEGER_FIELD_TYPE:
                cell.number_format = FORMAT_NUMBER
            if field_metadata["type"] == DECIMAL_FIELD_TYPE:
                cell.number_format = FORMAT_NUMBER_COMMA_SEPARATED1
            if field_metadata["type"] == FLAG_FIELD_TYPE:
                cell.number_format = FORMAT_TEXT

            return cell

        data_row = [
            _get_action_cell(ws),
            get_product_id_cell(),
            get_product_name_cell(),
            get_parent_name_cell() if mass_update_template.is_parent_id_column_required() else None,
            get_entity_cell() if mass_update_template.is_entity_id_column_required() else None,
        ]

        data_validators_dict[action].add(f"A{row_idx}")

        if mass_update_template.parent_entity_id_column in data_validators_dict.keys():
            data_validators_dict[mass_update_template.parent_entity_id_column].add(f"C{row_idx}")

        for column_idx, mass_update_template_field in enumerate(mass_update_template.fields, start=6):
            field_metadata = field_metadatas_dict.get(mass_update_template_field.field_id)
            data_row.append(
                get_data_cell(
                    field_metadata,
                    mass_update_template_field,
                    product_initial_data_by_field.get(mass_update_template_field.field_id)
                    if product_initial_data_by_field
                    else None,
                )
            )
            if field_metadata and field_metadata["id"] in data_validators_dict.keys():
                data_validators_dict[field_metadata["id"]].add(
                    f"{get_column_letter(column_idx)}{row_idx}"
                )

        ws.append(data_row)

    # retrieve product-initial-data for all products
    product_initial_data_by_product_dict = get_products_initial_data(
        project.product_type,
        list(field_metadatas_dict.keys()),
        list(products_entities_dict.keys()),
        project.delivery_task.target_date.strftime("%Y-%m-%d"),
        with_sanctuarized_data=True,
        with_business_rules_fields=False,
    )

    row_idx = 1
    for product_idx, (product_id, product_details) in enumerate(products_entities_dict.items(), 1):
        if product_id not in product_initial_data_by_product_dict.keys():
            continue

        product_initial_data_dict = expand_product_initial_data(
            product_initial_data_by_product_dict[product_id],
            field_metadatas_dict
        )

        for (object_id, _, parent_id), product_initial_data_by_field in product_initial_data_dict.items():
            row_idx += 1
            write_rows(
                row_idx=row_idx,
                product_id=product_id,
                action=MODIFY_ACTION,
                parent_id=parent_id,
                object_id=object_id,
                product_initial_data_by_field=product_initial_data_by_field,
                style=PRODUCT_STYLES[product_idx % 2],
            )

        # extra empty rows if allow creation
        if mass_update_template.allow_create_action:
            for _ in range(10):
                row_idx += 1
                write_rows(
                    row_idx=row_idx,
                    product_id=product_id,
                    action=UNUSED_ACTION,
                    parent_id=None,
                    object_id=None,
                    product_initial_data_by_field={},
                    style=PRODUCT_STYLES[product_idx % 2],
                )


# ============================================================
# ================= SPECIFIC FEES TEMPLATE ===================
# ============================================================

def create_specific_fees_template_workbook(adl_fees_data: list[dict]) -> Workbook:
    """
    Template spécifique pour task.name == 'Upload Specific Fees template'

    - Header noir + texte blanc (comme ton screenshot)
    - Toutes les colonnes read-only
    - Seulement 2 colonnes éditables : New ADL in / New ADL out
    - Validation numérique (decimal >= 0) sur ces 2 colonnes (errorStyle=stop)
    """
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Specific Fees"

    # Styles simples dédiés (sans toucher aux NamedStyle existants)
    black_fill = PatternFill(fill_type="solid", fgColor="000000")
    dark_fill = PatternFill(fill_type="solid", fgColor="1F1F1F")
    light_edit_fill = PatternFill(fill_type="solid", fgColor="E6E6E6")

    font_white_bold = Font(name=FONT_NAME, size=11, bold=True, color="FFFFFF")
    font_black = Font(name=FONT_NAME, size=11, color="000000")
    align_center = Alignment(horizontal="center", vertical="center", wrap_text=True)
    align_left = Alignment(horizontal="left", vertical="center", wrap_text=True)

    # Title row (ligne 1)
    ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=14)
    c = ws.cell(row=1, column=1, value="BNP PARIBAS EASY - Update of real ADL fees (in bps)")
    c.fill = black_fill
    c.font = font_white_bold
    c.alignment = align_left
    c.border = DEFAULT_BORDER
    c.protection = Protection(locked=True)
    ws.row_dimensions[1].height = 24

    # Group header (ligne 2)
    groups = [
        (1, 7, "Product / Share"),
        (8, 9, "Current ADL fees"),
        (10, 11, "Maximum ADL fees"),
        (12, 13, "New ADL fees (editable)"),
        (14, 14, "Effective NAV date"),
    ]
    for start_col, end_col, label in groups:
        ws.merge_cells(start_row=2, start_column=start_col, end_row=2, end_column=end_col)
        cell = ws.cell(row=2, column=start_col, value=label)
        cell.fill = black_fill
        cell.font = font_white_bold
        cell.alignment = align_center
        for col in range(start_col, end_col + 1):
            cc = ws.cell(row=2, column=col)
            cc.border = DEFAULT_BORDER
            cc.protection = Protection(locked=True)
    ws.row_dimensions[2].height = 20

    # Column titles (ligne 3)
    headers = [
        "Umbrella name",
        "Sub-fund name",
        "Sub-fund ALADDIN code",
        "Sub-fund status",
        "Share name",
        "ISIN code",
        "Share status",
        "ADL in",
        "ADL out",
        "Max ADL in",
        "Max ADL out",
        "New ADL in",
        "New ADL out",
        "Effective NAV date",
    ]
    for col_idx, h in enumerate(headers, start=1):
        cell = ws.cell(row=3, column=col_idx, value=h)
        cell.fill = dark_fill
        cell.font = font_white_bold
        cell.alignment = align_center
        cell.border = DEFAULT_BORDER
        cell.protection = Protection(locked=True)
    ws.row_dimensions[3].height = 34

    ws.freeze_panes = "A4"

    # Column widths (adaptées à ton export)
    col_widths = {
        1: 22, 2: 34, 3: 22, 4: 16,
        5: 55, 6: 18, 7: 16,
        8: 10, 9: 10,
        10: 12, 11: 12,
        12: 12, 13: 12,
        14: 18
    }
    for col_idx, w in col_widths.items():
        ws.column_dimensions[get_column_letter(col_idx)].width = w

    # Data validation: decimal >= 0, stop
    dv_num = DataValidation(type="decimal", operator="greaterThanOrEqual", formula1="0", allow_blank=True)
    dv_num.errorStyle = "stop"
    dv_num.showErrorMessage = True
    dv_num.errorTitle = "Invalid value"
    dv_num.error = "Only numeric values are allowed (decimal >= 0)."
    dv_num.promptTitle = "New ADL fees"
    dv_num.prompt = "Enter a numeric value (decimal >= 0)."
    ws.add_data_validation(dv_num)

    # Write data
    start_row = 4
    for i, row in enumerate(adl_fees_data):
        r = start_row + i

        # Champs attendus depuis ton endpoint (Postman)
        # umb_name_lbl, sbf_name, prod_cd_valu, sbf_stat_lbl, sha_name, isin_cd, sha_stat_lbl,
        # adl_in_fee, adl_out_fee, max_adl_in_fee, max_adl_out_fee, nav_valuation_date
        values = [
            row.get("umb_name_lbl"),
            row.get("sbf_name"),
            row.get("prod_cd_valu"),
            row.get("sbf_stat_lbl"),
            row.get("sha_name"),
            row.get("isin_cd"),
            row.get("sha_stat_lbl"),
            row.get("adl_in_fee"),
            row.get("adl_out_fee"),
            row.get("max_adl_in_fee"),
            row.get("max_adl_out_fee"),
            None,  # New ADL in (editable)
            None,  # New ADL out (editable)
            row.get("nav_valuation_date"),
        ]

        for col_idx, v in enumerate(values, start=1):
            cell = ws.cell(row=r, column=col_idx, value=v)
            cell.font = font_black
            cell.border = DEFAULT_BORDER
            cell.alignment = align_left if col_idx <= 7 else align_center

            # default locked
            cell.protection = Protection(locked=True)

            # Formats
            if col_idx in (8, 9, 10, 11):
                # valeurs fees: laisser en texte si source est string; sinon format numérique
                # (si tu veux forcer: cell.number_format = "0.00")
                pass

            if col_idx == 14:
                cell.number_format = "yyyy-mm-dd"

            # Editable columns (12,13)
            if col_idx in (12, 13):
                cell.fill = light_edit_fill
                cell.protection = Protection(locked=False)
                cell.number_format = "0.00"

    last_row = max(start_row, start_row + len(adl_fees_data) - 1)

    # Apply validation on both editable columns
    dv_num.add(f"{get_column_letter(12)}{start_row}:{get_column_letter(12)}{last_row}")
    dv_num.add(f"{get_column_letter(13)}{start_row}:{get_column_letter(13)}{last_row}")

    # Protect sheet (locked everywhere except unlocked cells)
    ws.protection.enabled = True
    ws.protection.selectLockedCells = True
    ws.protection.selectUnlockedCells = True

    return wb


# ============================================================
# ===================== ENTRY POINT ==========================
# ============================================================

def retrieve_mass_update_template(task, product_ids=None):
    """
    Existing behavior:
    - Load generic template from COS
    - Fill workbook based on mass_update_template / field metadata / products
    Added behavior:
    - If task.name == 'Upload Specific Fees template' -> create specific template workbook
    """
    if product_ids is None:
        product_ids = []

    if not task.mass_update_template:
        raise TaskWithoutMassUpdateTemplate(task.id)

    # ============================================================
    # SPECIFIC CASE: Upload Specific Fees template
    # ============================================================
    if task.name == "Upload Specific Fees template":
        with SessionCriticalActionManager(
            "Getting specific fees data from smartgps",
            db.session,
            DEV_TEAM_EMAILS,
        ):
            # ton client.get_adl_fees_data(product_ids) renvoie déjà les données OK
            payload = get_adl_fees_data(product_ids)

            # payload peut être:
            # - une liste directe
            # - ou { "SIN": [...], "SUB": [...], ... }
            if isinstance(payload, dict):
                adl_fees_data = (payload.get("SUB") or []) + (payload.get("SIN") or [])
            else:
                adl_fees_data = payload or []

            wb = create_specific_fees_template_workbook(adl_fees_data)
            return wb

    # ============================================================
    # GENERIC CASE (existing)
    # ============================================================
    mass_update_template = task.mass_update_template

    # retrieve cos template file
    mass_update_file_name = str(mass_update_template.id) + mass_update_template.extension

    with SessionCriticalActionManager(
        f"Getting file {mass_update_file_name} from cos",
        db.session,
        DEV_TEAM_EMAILS,
    ):
        cos_mu_file = cos_read_file(mass_update_file_name)

    try:
        wb = openpyxl.load_workbook(filename=BytesIO(cos_mu_file), data_only=True)
        wb.iso_dates = True
    except Exception as e:
        logging.error("Could not load template from COS")
        logging.error(e)
        raise

    # remove default unused worksheet
    if "Sheet" in wb.sheetnames:
        del wb["Sheet"]

    # create styles
    create_named_style(wb)

    # retrieve metadata
    if not task.project.product_type:
        field_metadatas = get_fields_metadata([], "")
    else:
        field_metadatas = get_fields_metadata([], task.project.product_type)

    field_metadatas_dict = {field_metadata["id"]: field_metadata for field_metadata in field_metadatas}

    products_entities_dict = get_products_with_entities(
        task.project,
        product_ids,
        mass_update_template.entity_type,
        [mass_update_template.parent_entity_type] if mass_update_template.is_parent_id_column_required() else [],
    )

    # create additional sheets (reference lists)
    create_field_values_worksheets(wb, field_metadatas)

    # create data sheet + validators
    data_validators_dict = create_data_worksheets(wb, mass_update_template, field_metadatas_dict)

    # populate
    populate_data_worksheets(
        wb,
        task.project,
        mass_update_template,
        field_metadatas_dict,
        data_validators_dict,
        products_entities_dict,
    )

    return wb


---

Points importants (pour éviter des surprises)

1. Colonnes éditables : New ADL in et New ADL out (colonnes 12 et 13) sont déverrouillées (locked=False) et ont une validation (decimal >= 0, errorStyle stop).


2. Toutes les autres colonnes : locked=True => read-only.


3. Ton payload : j’ai géré le cas où get_adl_fees_data() renvoie :



soit une liste directe

soit un dict du style { "SIN": [...], "SUB": [...] } (comme tu m’as montré dans Postman)


4. Look & Feel : header noir / blanc, et cellules modifiables en gris clair.
Si tu veux exactement les mêmes couleurs hex que dans l’excel final (black / dark / etc.), je peux ajuster, mais là on est déjà très proche.




---

Si tu veux, je peux aussi te rajouter :

une table Excel (comme vos create_reference_worksheet utilisent Table)

un filtre sur les headers

et une mise en forme conditionnelle sur New ADL in/out (ex: rouge si > max, etc.)
Mais j’ai volontairement gardé une version safe + simple pour que ça passe en prod direct.
