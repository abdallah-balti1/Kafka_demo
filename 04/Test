Merci pour les captures ! Voici une version mise √† jour et compl√®te de ton discussion.service.ts, qui int√®gre les √©l√©ments suivants :


---

‚úÖ Changements apport√©s :

Ajout d‚Äôun Subject pour √©mettre les nouvelles discussions en temps r√©el.

Ajout du champ isExpired pour griser automatiquement les discussions vieilles de plus d‚Äôune heure.

TypeScript propre avec les types g√©n√©riques (Observable<ItemResponse<Discussion>>, etc.).

Regroupement logique et lisibilit√© am√©lior√©e.



---

‚úÖ Nouveau fichier discussion.service.ts complet :

import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, Subject } from 'rxjs';
import { retry, catchError } from 'rxjs/operators';

import {
  CHAT_WITH_API_BASE_URL,
  API_VERSION,
  getHttpHeaders,
  handleError
} from '../../helpers';

import {
  ItemResponse,
  ListItemResponse
} from '../../models';

import { Discussion } from 'src/app/models/discussion';

@Injectable({
  providedIn: 'root'
})
export class DiscussionService {
  private requestUrl = `${CHAT_WITH_API_BASE_URL}/api/${API_VERSION}/discussions`;

  // Pour la mise √† jour des ratings (d√©j√† pr√©sent)
  private ratingUpdateSource = new Subject<{ id: number; rating: number }>();
  ratingUpdated$ = this.ratingUpdateSource.asObservable();

  // ‚úÖ Pour notifier les nouvelles discussions cr√©√©es
  private newDiscussionSource = new Subject<Discussion>();
  newDiscussion$ = this.newDiscussionSource.asObservable();

  // Local cache (optionnel)
  private discussions: Discussion[] = [];

  constructor(public httpClient: HttpClient) {}

  // ‚úÖ Notifier une nouvelle discussion
  emitNewDiscussion(discussion: Discussion): void {
    discussion.isExpired = false;
    this.discussions.unshift(discussion);
    this.newDiscussionSource.next(discussion);
  }

  // ‚úÖ Calcul automatique de l'expiration (1 heure)
  setDiscussionsWithExpiration(discussions: Discussion[]) {
    const now = Date.now();
    this.discussions = discussions.map(disc => {
      const start = new Date(disc.startDate).getTime();
      disc.isExpired = now - start > 3600000;
      return disc;
    });
  }

  // Utilis√© pour mettre √† jour une note
  notifyRatingUpdate(data: { id: number; rating: number }) {
    this.ratingUpdateSource.next(data);
  }

  // üîç Rechercher une discussion
  search(query: any) {
    const data = {
      SearchedText: query.term
    };
    const url = `${this.requestUrl}/search`;
    return this.httpClient.post<any>(url, data, getHttpHeaders());
  }

  // üì• R√©cup√©rer les discussions de l'utilisateur
  getDiscussions(userProfileCode: string): Observable<ListItemResponse<Discussion>> {
    const params = new HttpParams().set('userProfileCode', userProfileCode);
    const httpOptions = {
      getHttpHeaders,
      params
    };

    const result = this.httpClient
      .get<ListItemResponse<Discussion>>(this.requestUrl, httpOptions)
      .pipe(retry(1), catchError(handleError));

    return result;
  }

  // üö´ D√©sactiver / archiver une discussion
  disableDiscussion(command: any): Observable<ItemResponse<Discussion>> {
    const url = `${this.requestUrl}/archive`;
    return this.httpClient.put<ItemResponse<Discussion>>(url, command, getHttpHeaders());
  }

  // ‚úèÔ∏è Mettre √† jour une discussion existante
  updateDiscussion(discussion: any): Observable<any> {
    const url = `${this.requestUrl}/update`;
    return this.httpClient.put(url, discussion);
  }
}


---

‚úÖ Prochaine √©tape

Assure-toi que ton composant chat-conversation-list.component.ts :

S‚Äôabonne √† newDiscussion$ pour afficher les nouvelles discussions imm√©diatement.

Utilise discussion.isExpired pour afficher ou griser les discussions.


Souhaites-tu que je mette √† jour aussi ce composant avec les derni√®res bonnes pratiques ?










Voici la version mise √† jour compl√®te de ton fichier chat-conversation-list.component.ts, int√©grant :

L‚Äôabonnement √† newDiscussion$ pour faire appara√Ætre une discussion imm√©diatement apr√®s sa cr√©ation.

La logique permettant de griser les discussions vieilles de plus d‚Äôune heure (isExpired).

La protection pour emp√™cher le clic sur ces discussions expir√©es.



---

import { Component, OnInit, OnDestroy } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';
import { Subscription } from 'rxjs';
import { DiscussionService } from 'src/app/services/ChatWith/discussion.service';
import { SignalRService } from 'src/app/services/signalr.service';
import { HelperService } from 'src/app/services/helper.service';
import { Discussion } from 'src/app/models/discussion';

@Component({
  selector: 'app-chat-conversation-list',
  templateUrl: './chat-conversation-list.component.html',
  styleUrls: ['./chat-conversation-list.component.scss']
})
export class ChatConversationListComponent implements OnInit, OnDestroy {
  public activeDiscussions: Discussion[] = [];
  public archivedDiscussions: Discussion[] = [];
  private subscriptions: Subscription = new Subscription();

  constructor(
    private discussionService: DiscussionService,
    private signalRService: SignalRService,
    private helperService: HelperService,
    private router: Router,
    private route: ActivatedRoute
  ) {}

  ngOnInit(): void {
    // 1. Charger les discussions existantes via getDiscussions() ‚Äî en supposant que tu appelles aussi discussionService.setDiscussionsWithExpiration(...)
    this.subscriptions.add(
      this.helperService.selectDiscussions$.subscribe(val => {
        // Exemple : tu pourrais √©galement initier le chargement ici
      })
    );
    this.loadAllDiscussions();

    // 2. R√©agir √† une nouvelle discussion √©mise
    this.subscriptions.add(
      this.discussionService.newDiscussion$.subscribe(newDisc => {
        newDisc.isExpired = false;
        this.activeDiscussions.unshift(newDisc);
        // Optionnel : s√©lectionner automatiquement la nouvelle discussion
      })
    );
  }

  ngOnDestroy(): void {
    this.subscriptions.unsubscribe();
  }

  loadAllDiscussions(): void {
    this.helperService.setLoading(true);
    const userProfileCode = this.helperService.currentUserProfileCode;
    this.discussionService.getDiscussions(userProfileCode).subscribe(result => {
      const discussions = this.fromQueryResultToDiscussionList(result);
      this.discussionService.setDiscussionsWithExpiration(discussions);
      this.activeDiscussions = this.discussionService.getDiscussions().filter(d => !d.isExpired);
      this.archivedDiscussions = this.discussionService.getDiscussions().filter(d => d.isExpired);
      this.helperService.setLoading(false);
    });
  }

  fromQueryResultToDiscussionList(result: any): Discussion[] {
    const items: Discussion[] = [];
    result.items.forEach((item: any) => {
      const disc = new Discussion(
        item.item.id,
        item.item.name,
        item.item.userUid,
        item.item.startDate,
        item.item.endDate,
        item.item.isActive,
        item.item.formatedEndDate,
        item.item.totalTokens,
        item.item.promptTokens,
        item.item.completionTokens,
        item.item.totalCost,
        item.item.message,
        false, // isExpired initialis√© √† false, calcul√© plus tard
        item.item.rate
      );
      disc.totalMessages = item.item.totalMessages;
      items.push(disc);
    });
    return items;
  }

  changeDiscussion(discussionId: number, index: number): void {
    const discussion = this.activeDiscussions[index];
    if (discussion.isExpired) {
      return;
    }
    this.helperService.setLoading(true);
    this.signalRService.sendDiscussionIdEvent(discussionId);
    this.activeDiscussions.forEach((item, i) => {
      item.selected = (i === index);
    });
    this.router.navigate(['/pages/chat/discussion/', discussionId]).then(success => {
      if (!success) {
        this.signalRService.disconnectFromDiscussion(discussionId.toString());
      }
      this.helperService.setLoading(false);
    });
  }

  createDiscussion(): void {
    this.signalRService.createDiscussion('new discussion').then(discussionId => {
      if (discussionId !== -1) {
        const newDisc = new Discussion(
          discussionId,
          'new discussion',
          this.helperService.currentUserUid,
          new Date().toISOString(),
          null,
          true,
          '',
          0,
          0,
          0,
          0,
          '',
          false,
          0
        );
        this.discussionService.emitNewDiscussion(newDisc);
      }
    });
  }
}


---

üöß Ce que fait cette version

√âl√©ments	Fonctionnalit√©

setDiscussionsWithExpiration()	Calcule isExpired pour chaque discussion en fonction du startDate
.newDiscussion$	Permet d‚Äôafficher en temps r√©el une nouvelle discussion dans la sidebar
changeDiscussion()	Emp√™che la s√©lection des discussions expir√©es
createDiscussion()	Int√®gre la nouvelle discussion dans le service pour publication √† tous les abonn√©s



---

‚úÖ Actions requises :

1. Mets √† jour ton service DiscussionService avec la version fournie pr√©c√©demment.


2. Assure-toi dans ton template chat-conversation-list.component.html qu‚Äôil applique une classe CSS expired aux √©l√©ments discut√©s via une condition *ngFor.


3. Ajoute le style .expired { opacity: 0.5; pointer-events: none; } pour griser les items expir√©s.



Si tu veux, je peux aussi t‚Äôenvoyer le markup HTML et le CSS √† adapter en plus !

