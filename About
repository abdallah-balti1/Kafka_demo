import axiosInstance from "utils/customizedAxios";
import { User } from "schemas/User";
import { Poc } from "schemas/pocs";

export const assignUserToPoc = async (
  user: User,
  poc: Poc,
  startDate: string,
  endDate: string
): Promise<void> => {
  const payload = {
    user: {
      userId: user.userId // Seul l'ID est nécessaire pour le backend
    },
    poc: {
      id: poc.id
    },
    startUsing: startDate,
    endUsing: endDate
  };

  await axiosInstance.put("/manage/user/poc", payload);
};

export const removeUserPoc = async (userId: string): Promise<void> => {
  await axiosInstance.delete(`/manage/user/poc`, {
    data: { userId } // Envoie userId dans le body
  });
};







import { AxiosResponse } from "axios";
import { User } from "schemas/user";
import axiosInstance from "utils/customizedAxios";

const usersUrl = "/users";
const CACHE_DURATION = 30000; // 30 secondes seulement pour plus de réactivité

let usersCache: User[] = [];
let cacheTimestamp = 0;

export const getUsersWithPocs = async (): Promise<User[]> => {
  const now = Date.now();
  
  if (now - cacheTimestamp > CACHE_DURATION || usersCache.length === 0) {
    try {
      const response: AxiosResponse<User[]> = await axiosInstance.get(usersUrl, {
        params: {
          fields: "userId,firstName,lastName,mail,role,active,pocs" // Seuls les champs nécessaires
        }
      });
      
      usersCache = response.data;
      cacheTimestamp = now;
    } catch (error) {
      console.error("Fetch users error:", error);
      throw error;
    }
  }
  
  return usersCache;
};

// ... (keep other functions same)







import React, { useState, useEffect, useMemo } from "react";
import { getUsersWithPocs, updateUser } from "services/users";
import { assignUserToPoc, removeUserPoc } from "services/userPocService";
import { User } from "schemas/user";
import { Poc } from "schemas/pocs";

type Props = {
  user: User;
  onClose: () => void;
  onSuccess: () => void;
};

const UserEditModal: React.FC<Props> = ({ user, onClose, onSuccess }) => {
  // State
  const [formData, setFormData] = useState<User>({ ...user });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");
  const [localPoc, setLocalPoc] = useState<Poc | null>(null);
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [usersData, setUsersData] = useState<User[]>([]);

  // Optimized data derivation
  const { availablePocs, currentPoc } = useMemo(() => {
    const currentUser = usersData.find(u => u.userId === user.userId);
    const uniquePocs = [...new Set(
      usersData.flatMap(u => u.pocs || [])
        .filter((p): p is Poc => !!p)
        .map(p => p.id)
    ].map(id => 
      usersData.flatMap(u => u.pocs).find(p => p?.id === id)
    ).filter(Boolean) as Poc[];

    return {
      availablePocs: uniquePocs,
      currentPoc: currentUser?.pocs?.[0] || null
    };
  }, [usersData, user.userId]);

  // Load data with optimized caching
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      try {
        const data = await getUsersWithPocs();
        setUsersData(data);
        
        // Initialize current POC
        const userData = data.find(u => u.userId === user.userId);
        if (userData?.pocs?.[0]) {
          setLocalPoc(userData.pocs[0]);
          setStartDate(userData.pocs[0].startDate || "");
          setEndDate(userData.pocs[0].endDate || "");
        }
      } catch (err) {
        console.error("Data load error:", err);
        setError("Failed to load data");
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [user.userId]);

  // Handle POC removal
  const handleRemovePoc = async () => {
    setError("");
    setIsLoading(true);
    
    try {
      await removeUserPoc(formData.userId);
      setLocalPoc(null);
      setStartDate("");
      setEndDate("");
      
      // Force cache refresh
      const updatedUsers = await getUsersWithPocs();
      setUsersData(updatedUsers);
      
    } catch (err) {
      console.error("Remove POC error:", err);
      setError("Failed to remove POC");
    } finally {
      setIsLoading(false);
    }
  };

  // Form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);

    try {
      await updateUser(formData.userId, formData);

      if (localPoc) {
        await assignUserToPoc(formData, localPoc, startDate, endDate);
      }

      onSuccess();
      onClose();
    } catch (err) {
      console.error("Save error:", err);
      setError(err instanceof Error ? err.message : "Save failed");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md animate-fade-in">
        {/* Form content remains same as before */}
        {/* ... */}
        
        {/* Updated POC removal button */}
        {localPoc && (
          <button
            type="button"
            onClick={handleRemovePoc}
            disabled={isLoading}
            className={`px-4 py-2 text-red-600 hover:text-red-800 ${
              isLoading ? 'opacity-50 cursor-not-allowed' : ''
            }`}
          >
            {isLoading ? 'Removing...' : 'Remove POC'}
          </button>
        )}
        
        {/* ... */}
      </div>
    </div>
  );
};

export default UserEditModal;
