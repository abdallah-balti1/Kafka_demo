/* eslint-disable complexity */
import React, { lazy, useEffect, useMemo, useState } from 'react';

import { FormattedMessage, useIntl } from 'react-intl';
import NewDropdown from '@component-studio/ui/NewDropdown';
import IconButton from 'components/Icon/IconButton';
import Modal from 'components/Modal';
import ModalLayout from 'components/Modal/ModalLayout';
import { OBJECT_TYPE_ACTOR } from 'constants/objectTypes';
import {
  PRODUCT_TYPES,
  PRODUCT_TYPE_MANDATE,
  PRODUCT_TYPE_SINGLE,
  PRODUCT_TYPE_SUBFUND,
  PRODUCT_TYPE_UMBRELLA,
} from 'constants/productObjects';
import {
  PROJECT_MODEL_TYPE_MASS_UPDATE,
  PROJECT_MODEL_TYPE_MASS_UPDATE_ACTOR,
} from 'constants/projectModel';
import FormSubcategory from 'pages/Project/components/OperationalItems/components/FormSubcategory';
import { lazy, useEffect, useMemo, useState, Suspense } from 'react';
import { FormattedMessage } from 'react-intl';
import Grid from 'styled-components-grid';
import { LoadingIndicatorWithPosition } from 'styles';
// @flow/fixme flow does not recognize default export from react-select
import { useFetchMuActors } from 'redux/entities/massUpdateTemplate/hooks.js';

import FormCategory from 'pages/Project/components/OperationalItems/components/FormCategory';
import Style from './MassUpdateProductSelection.style';

const ConfirmationDialog = lazy(() =>
  import(/* webpackChunkName: "ConfirmationDialog" */ 'components/ConfirmationDialog'),
);

// ===================================================================================
// TYPES
// ===================================================================================

export type OwnPropsType = {
  taskId: number,
  onCloseClick: () => void,
  downloadMassUpdateTemplate: (taskId: number, productIds: string[]) => void,
  project: ProjectTypeForUi,
  umbrellas: UmbrellasByIdStateType,
};

export type MapDispatchToPropsType = {
  fetchProducts: (
    productType: ?string,
    umbrellaId: ?string,
    searchByUmbrella: boolean,
    actorUid: ?string,
    teamCd: ?string,
    // --- ADDED ---
    mgmtComp: ?string,
    domCtry: ?string,
    umbName: ?string,
  ) => void,
  fetchFilteredMuProducts: (
    productType: ?string,
    umbrellaId: ?string,
    searchByUmbrella: boolean,
    actorUid: ?string,
    teamCd: ?string,
    // --- ADDED ---
    mgmtComp: ?string,
    domCtry: ?string,
    umbName: ?string,
  ) => void,
  fetchUmbrellas: () => void,
};

export type MapStateToPropsType = {
  products: ProductType[],
  filteredMuProducts: ProductType[],
  token: ?string,
  isLoading: ?boolean,
};

type SelectedItemType = { id: string, name: string };
type VisibleProductType = Array<SelectedItemType>;

type FormikValuesType = {
  selectedItems: SelectedItemType,
};

type FormikPropsType = {
  setFieldValue: (name: string, value: string | SelectedItemType) => void,
  values: FormikValuesType,
};

export type PropsType = OwnPropsType & MapDispatchToPropsType & MapStateToPropsType & { formik: FormikPropsType };

// ===================================================================================
// HELPER FUNCTIONS
// ===================================================================================

export const filterProducts = (products: ProductType[], filter: string): VisibleProductType =>
  products
    .filter(
      product =>
        product.official_name && product.official_name.toLowerCase().includes(filter.toLowerCase()),
    )
    .map(product => ({ id: product.id, name: product.official_name }))
    .sort((a, b) => (a.name && b.name && a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1));

export const filterUmbrellas = (
  umbrellas: UmbrellasByIdStateType,
  filter: string,
): VisibleProductType =>
  Object.keys(umbrellas)
    .filter(
      umbrellaId =>
        umbrellas[umbrellaId].name
          .toLowerCase()
          .includes(filter.toLowerCase()),
    )
    .map(umbrellaId => ({ id: umbrellaId, name: umbrellas[umbrellaId].name }))
    .sort((a, b) => (a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1));

// ===================================================================================
// MAIN COMPONENT
// ===================================================================================

const MassUpdateProductSelection = ({
  taskId,
  onCloseClick,
  downloadMassUpdateTemplate,
  fetchProducts,
  fetchFilteredMuProducts,
  products,
  filteredMuProducts,
  umbrellas,
  fetchUmbrellas,
  token,
  project,
  isLoading,
  formik,
}: PropsType) => {
  const [filter, setFilter] = useState<string>('');
  const [actorNames, setActorNames] = useState([]);
  const [actorsTeams, setActorsTeams] = useState([]);
  const [selectedActor, setSelectedActor] = useState({ value: '', label: '' });
  const [selectedTeam, setSelectedTeam] = useState({ value: '', label: '' });

  // --- ADDED ---
  const [selectedMgmtComp, setSelectedMgmtComp] = useState({ value: '', label: '' });
  const [selectedDomCtry, setSelectedDomCtry] = useState({ value: '', label: '' });
  const [selectedUmbName, setSelectedUmbName] = useState({ value: '', label: '' });
  // --- END ADDED ---

  const [productsFiltered, setProductsFiltered] = useStateArray<ProductType>([]);
  const { value: actors } = useFetchMuActors(token, false, null);

  // --- ADDED ---
  // Create dropdown options from the products list
  const mgmtCompOptions = useMemo(() => {
    if (!products) return [];
    const uniqueValues = [...new Set(products.map(p => p.mgmt_comp_lbl).filter(Boolean))];
    return uniqueValues.map(val => ({ value: val, label: val })).sort((a, b) => (a.label > b.label ? 1 : -1));
  }, [products]);

  const domCtryOptions = useMemo(() => {
    if (!products) return [];
    const uniqueValues = [...new Set(products.map(p => p.domiciliation_ctry).filter(Boolean))];
    return uniqueValues.map(val => ({ value: val, label: val })).sort((a, b) => (a.label > b.label ? 1 : -1));
  }, [products]);

  const umbNameOptions = useMemo(() => {
    if (!products) return [];
    const uniqueValues = [...new Set(products.map(p => p.umb_name_label).filter(Boolean))];
    return uniqueValues.map(val => ({ value: val, label: val })).sort((a, b) => (a.label > b.label ? 1 : -1));
  }, [products]);
  // --- END ADDED ---

  useEffect(() => {
    if (filter) {
      setProductsFiltered(
        filteredMuProducts
          .sort((a, b) =>
            a.official_name.toLowerCase() > b.official_name.toLowerCase() ? 1 : -1,
          )
          .filter(
            product =>
              product.official_name && product.official_name.includes(filter),
          ),
      );
    } else {
      setProductsFiltered(
        filteredMuProducts.sort((a, b) =>
          a.official_name.toLowerCase() > b.official_name.toLowerCase() ? 1 : -1,
        ),
      );
    }
  }, [filter, filteredMuProducts]);

  useEffect(() => {
    if (actors) {
      setActorNames(
        actors.map(actor => {
          return { value: actor.id, label: `${actor.actor_name} ${actor.actor_first_name}` };
        }),
      );
      const actorTeamsArr = actors.map(actor => {
        return { value: actor.id, label: `${actor.team_chg_lbl}` };
      });
      const teamsLabels = actorTeamsArr.map(actor => {
        return actor.label;
      });
      setActorsTeams(
        actorTeamsArr
          .filter(({ label }, index) => !teamsLabels.includes(label, index + 1))
          .sort((a, b) => (a.label.toLowerCase() > b.label.toLowerCase() ? 1 : -1)),
      );
    }
  }, [actors]);

  useEffect(() => {
    const [selectedActorFirstName, selectedActorLastName] = selectedActor
      ? selectedActor.label.split(' ')
      : ['', ''];
    const filteredActorsByName =
      actors &&
      actors.filter(
        actor =>
          actor.actor_first_name === selectedActorFirstName &&
          actor.actor_name === selectedActorLastName,
      );
    const actorUid =
      filteredActorsByName && filteredActorsByName.length > 0 ? filteredActorsByName[0].uid : '';
    const filteredActorsByTeam =
      actors && actors.filter(actor => selectedTeam.label === actor.team_chg_lbl);
    const teamCd =
      filteredActorsByTeam && filteredActorsByTeam.length > 0
        ? filteredActorsByTeam[0].team_chg_cd
        : '';
    const isActorOrTeamCdAvailable = (actorUid !== '' || teamCd !== '');

    // --- ADDED ---
    const mgmtComp = selectedMgmtComp?.value || '';
    const domCtry = selectedDomCtry?.value || '';
    const umbName = selectedUmbName?.value || '';
    
    // This variable now checks all filters
    const isAnyFilterAvailable = 
         (actorUid !== '' || teamCd !== '') || 
         (mgmtComp !== '') || 
         (domCtry !== '') || 
         (umbName !== '');
    // --- END ADDED ---

    if (
      project.projectModel &&
      project.projectModel.name === PROJECT_MODEL_TYPE_MASS_UPDATE &&
      project.projectModel.name === PROJECT_MODEL_TYPE_MASS_UPDATE_ACTOR
    ) {
      if (isAnyFilterAvailable) { // --- UPDATED ---
        fetchFilteredMuProducts(null, null, false, actorUid, teamCd, mgmtComp, domCtry, umbName); // --- UPDATED ---
      } else {
        fetchProducts(null, null, false, actorUid, teamCd, mgmtComp, domCtry, umbName); // --- UPDATED ---
      }
    } else {
      switch (project.productType) {
        case PRODUCT_TYPE_SINGLE:
          if (isAnyFilterAvailable) { // --- UPDATED ---
            fetchFilteredMuProducts(
              PRODUCT_TYPES[PRODUCT_TYPE_SINGLE].smartgpsValue,
              null,
              false,
              actorUid,
              teamCd,
              mgmtComp, domCtry, umbName // --- UPDATED ---
            );
          } else {
            fetchProducts(PRODUCT_TYPES[PRODUCT_TYPE_SINGLE].smartgpsValue, null, false, actorUid, teamCd, mgmtComp, domCtry, umbName); // --- UPDATED ---
          }
          break;
        case PRODUCT_TYPE_SUBFUND:
          if (isAnyFilterAvailable) { // --- UPDATED ---
            fetchFilteredMuProducts(
              PRODUCT_TYPES[PRODUCT_TYPE_SUBFUND].smartgpsValue,
              null,
              false,
              actorUid,
              teamCd,
              mgmtComp, domCtry, umbName // --- UPDATED ---
            );
          } else {
            fetchProducts(PRODUCT_TYPES[PRODUCT_TYPE_SUBFUND].smartgpsValue, null, false, actorUid, teamCd, mgmtComp, domCtry, umbName); // --- UPDATED ---
          }
          break;
        case PRODUCT_TYPE_MANDATE:
          if (isAnyFilterAvailable) { // --- UPDATED ---
            fetchFilteredMuProducts(
              PRODUCT_TYPES[PRODUCT_TYPE_MANDATE].smartgpsValue,
              null,
              false,
              actorUid,
              teamCd,
              mgmtComp, domCtry, umbName // --- UPDATED ---
            );
          } else {
            fetchProducts(PRODUCT_TYPES[PRODUCT_TYPE_MANDATE].smartgpsValue, null, false, actorUid, teamCd, mgmtComp, domCtry, umbName); // --- UPDATED ---
          }
          break;
        case PRODUCT_TYPE_UMBRELLA:
          fetchUmbrellas();
          break;
        default:
          break;
      }
    }
  }, [
    actors,
    fetchFilteredMuProducts,
    fetchProducts,
    fetchUmbrellas,
    project.productType,
    project.projectModel,
    selectedActor,
    selectedTeam,
    // --- ADDED ---
    selectedMgmtComp,
    selectedDomCtry,
    selectedUmbName,
    // --- END ADDED ---
  ]);

  const visibleProducts = useMemo(
    () =>
      project.productType === PRODUCT_TYPE_UMBRELLA
        ? filterUmbrellas(umbrellas, filter)
        : filterProducts(products, filter),
    [project.productType, products, umbrellas, filter],
  );

  const { selectedItems } = formik.values;
  const isChecked = (product: VisibleProductType) => {
    return product.id in selectedItems;
  };

  const removeItem = (product: VisibleProductType) => {
    delete selectedItems[product.id];
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const removeItemById = (id: string) => {
    delete selectedItems[id];
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const addItem = (product: VisibleProductType) => {
    selectedItems[product.id] = product.name;
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const onItemClick = (product: VisibleProductType) => {
    if (isChecked(product)) {
      removeItem(product);
    } else {
      addItem(product);
    }
  };

  const removeAll = () => {
    formik.setFieldValue('selectedItems', {});
  };

  const selectAll = () => {
    if (filteredMuProducts.length > 0) {
      filteredMuProducts.forEach(product => {
        selectedItems[product.id] = product.name;
      });
    } else {
      visibleProducts.forEach(product => {
        selectedItems[product.id] = product.name;
      });
    }
    formik.setFieldValue('selectedItems', selectedItems);
  };

  const isFilterSelected =
    (selectedActor && selectedActor.label !== '') || (selectedTeam && selectedTeam.label !== '');

  const massUpdateModalTitle =
    project.projectModel &&
    project.projectModel.name === PROJECT_MODEL_TYPE_MASS_UPDATE &&
    project.projectModel.name === PROJECT_MODEL_TYPE_MASS_UPDATE_ACTOR
      ? 'Mass Update Products Selection'
      : 'Mass Update Products Selection' + ' (' + project.productType + ')';

  return (
    <ModalLayout
      title={massUpdateModalTitle}
      description="Select the products to fill the Mass Update Template"
      onCancel={onCloseClick}
      onConfirm={() => {
        downloadMassUpdateTemplate(taskId, Object.keys(selectedItems));
      }}
    >
      <Modal
        isOpen={isFilterSelected && isLoading && filteredMuProducts.length === 0}
        onCloseClick={() => {
          setSelectedActor({ value: '', label: '' });
          setSelectedTeam({ value: '', label: '' });
        }}
      >
        <Suspense fallback={<LoadingIndicatorWithPosition />}>
          <ConfirmationDialog
            title={<FormattedMessage id="MU_PRODUCTS_SELECTION.NO_PRODUCTS" />}
            isConfirmButtonHidden
            isCancelButtonHidden
          />
        </Suspense>
      </Modal>

      {project.projectModel && project.projectModel.name.includes(OBJECT_TYPE_ACTOR) && (
        <FormCategory categoryLabel="MASSUPDATE_FILTERS">
          <FormSubcategory subcategoryLabel={'Teams'}>
            <NewDropdown
              options={actorsTeams}
              isClearable
              value={selectedTeam}
              onChange={selectedOption => {
                setSelectedTeam(selectedOption);
              }}
            />
          </FormSubcategory>

          <FormSubcategory subcategoryLabel={'Actor Names'}>
            <NewDropdown
              key="actor"
              isClearable
              value={selectedActor}
              options={actorNames}
              onChange={selectedOption => {
                setSelectedActor(selectedOption);
              }}
            />
          </FormSubcategory>
          
          {/* --- ADDED --- */}
          <FormSubcategory subcategoryLabel={'Management Company'}>
            <NewDropdown
              key="mgmt-comp"
              isClearable
              options={mgmtCompOptions}
              value={selectedMgmtComp}
              onChange={setSelectedMgmtComp}
            />
          </FormSubcategory>

          <FormSubcategory subcategoryLabel={'Domiciliation Country'}>
            <NewDropdown
              key="dom-ctry"
              isClearable
              options={domCtryOptions}
              value={selectedDomCtry}
              onChange={setSelectedDomCtry}
            />
          </FormSubcategory>

          <FormSubcategory subcategoryLabel={'Umbrella Name'}>
            <NewDropdown
              key="umb-name"
              isClearable
              options={umbNameOptions}
              value={selectedUmbName}
              onChange={setSelectedUmbName}
            />
          </FormSubcategory>
          {/* --- END ADDED --- */}

        </FormCategory>
      )}

      <Style.Container>
        <FormSubcategory subcategoryLabel={'Products'}>
          <Style.FilterInputWithPlaceholder
            filter={filter}
            onChange={value => setFilter(value)}
          />
        </FormSubcategory>

        <Style.AvailableList>
          {isFilterSelected ? (
            productsFiltered.length === 0 ? (
              <LoadingIndicatorWithPosition />
            ) : (
              productsFiltered.map(product => (
                <AvailableItem
                  key={product.id}
                  colorName={product.official_name}
                  onClick={() => onItemClick(product)}
                  isChecked={isChecked(product)}
                />
              ))
            )
          ) : (
            visibleProducts.length > 0 &&
            visibleProducts.map(product => (
              <AvailableItem
                key={product.id}
                colorName={product.name}
                onClick={() => onItemClick(product)}
                isChecked={isChecked(product)}
              />
            ))
          )}
        </Style.AvailableList>
      </Style.Container>

      <Style.ListSeparatorContainer className="listSeparator">
        <IconButton onClick={() => selectAll()} slug="arrows-arrow-right" />
        <IconButton onClick={() => removeAll()} slug="arrows-arrow-left" />
      </Style.ListSeparatorContainer>

      <FormSubcategory subcategoryLabel={`Selection (${Object.keys(selectedItems).length})`}>
        <Style.SelectedItems>
          {Object.keys(selectedItems).map(id => (
            <Style.SelectedItem key={id}>
              {selectedItems[id]}
              <IconButton
                onClick={() => removeItemById(id)}
                slug="close"
                size={10}
              />
            </Style.SelectedItem>
          ))}
        </Style.SelectedItems>
      </FormSubcategory>
    </ModalLayout>
  );
};

export default MassUpdateProductSelection;
